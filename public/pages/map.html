<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Estelar 3D</title>
    <style>
        body { margin: 0; display: flex; }
        canvas { display: block; }
        #infoPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 200px;
        }
        #leftPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 150px;
        }
        button {
            margin-top: 10px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="infoPanel">
        <h3>Informações da Estrela</h3>
        <div id="starInfo">Selecione uma estrela para ver os detalhes.</div>
        <button id="enterExoplanet" style="display: none;">Entrar no Exoplaneta</button>
    </div>
    <div id="leftPanel">
        <button id="backButton">Voltar</button>
        <button id="downloadButton">Download</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="Estrela.js"></script> <!-- Importa a classe Estrela -->
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const estrelas = [];
        let estrelaSelecionada = null;
        let estrelaEscolhidaParaConstelacao = null;

        async function carregarEstrelas() {
            const response = await fetch('estrelas.json');
            const data = await response.json();

            data.forEach(item => {
                const estrela = new Estrela(item.x, item.y, item.z, item.tamanho);
                estrelas.push(estrela);
                scene.add(estrela.mesh);
            });
        }

        carregarEstrelas().then(() => {
            camera.position.set(0, 0, 20);

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };

            document.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            });

            document.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };

                    camera.rotation.y += deltaMove.x * 0.005; // Rotação ao redor do eixo Y
                    camera.rotation.x += deltaMove.y * 0.005; // Rotação ao redor do eixo X

                    // Limitar a rotação para evitar giro completo
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }

                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            });

            let targetZoom = camera.position.z;

            document.addEventListener('wheel', (event) => {
                targetZoom += event.deltaY * 0.05;
                targetZoom = Math.max(1, targetZoom);
            });

            document.addEventListener('mousedown', (event) => {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(estrelas.map(estrela => estrela.mesh));

                if (intersects.length > 0) {
                    const estrelaAtual = estrelas.find(estrela => estrela.mesh === intersects[0].object);
                    if (estrelaEscolhidaParaConstelacao === null) {
                        estrelaEscolhidaParaConstelacao = estrelaAtual;
                        if (estrelaSelecionada) {
                            estrelaSelecionada.deselecionar();
                        }
                        estrelaSelecionada = estrelaAtual;
                        estrelaSelecionada.selecionar();
                        mostrarInformacoes(estrelaSelecionada);
                        document.getElementById('enterExoplanet').style.display = 'block';
                    } else {
                        desenharLinha(estrelaEscolhidaParaConstelacao, estrelaAtual);
                        estrelaEscolhidaParaConstelacao = null;
                    }
                }
            });

            function mostrarInformacoes(estrela) {
                const infoPanel = document.getElementById('starInfo');
                infoPanel.innerHTML = `
                    <strong>Posição:</strong> (${estrela.x.toFixed(2)}, ${estrela.y.toFixed(2)}, ${estrela.z.toFixed(2)})<br>
                    <strong>Tamanho:</strong> ${estrela.tamanho}<br>
                `;
            }

            function desenharLinha(estrela1, estrela2) {
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(estrela1.x, estrela1.y, estrela1.z),
                    new THREE.Vector3(estrela2.x, estrela2.y, estrela2.z)
                ]);
                const linha = new THREE.Line(geometry, material);
                scene.add(linha);
            }

            function animate() {
                requestAnimationFrame(animate);

                camera.position.z += (targetZoom - camera.position.z) * 0.1; // Movimento suave de zoom
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(estrelas.map(estrela => estrela.mesh));

                estrelas.forEach(estrela => estrela.voltarTamanho());
                if (intersects.length > 0) {
                    intersects[0].object.scale.set(1.5, 1.5, 1.5);
                }

                renderer.render(scene, camera);
            }

            animate();

            document.getElementById('downloadButton').addEventListener('click', () => {
              renderer.render(scene, camera); // Renderiza a cena atual
              const dataURL = renderer.domElement.toDataURL('image/png');
              const link = document.createElement('a');
              link.href = dataURL;
              link.download = 'mapa_estelar.png';
              link.click();
          });
          

            document.getElementById('backButton').addEventListener('click', () => {
                window.history.back();
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>
</body>
</html>

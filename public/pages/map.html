<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Estelar 3D</title>
    <style>
        body { margin: 0; display: flex; }
        canvas { display: block; }
        #infoPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 200px;
        }
    </style>
</head>
<body>
    <div id="infoPanel">
        <h3>Informações da Estrela</h3>
        <div id="starInfo">Selecione uma estrela para ver os detalhes.</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="Estrela.js"></script> <!-- Importa a classe Estrela -->
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const estrelas = [];

        // Função para carregar estrelas do arquivo JSON
        async function carregarEstrelas() {
            const response = await fetch('estrelas.json');
            const data = await response.json();

            data.forEach(item => {
                const estrela = new Estrela(item.x, item.y, item.z, item.tamanho);
                estrelas.push(estrela);
                scene.add(estrela.mesh);
            });
        }

        carregarEstrelas().then(() => {
            camera.position.z = 20; // Aumentando a distância inicial da câmera

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let estrelaSelecionada = null;

            document.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            });

            document.addEventListener('mousedown', (event) => {
                // Raycaster para interação ao clicar
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(estrelas.map(estrela => estrela.mesh));

                if (intersects.length > 0) {
                    if (estrelaSelecionada) {
                        estrelaSelecionada.deselecionar(); // Desseleciona a estrela anterior
                    }

                    estrelaSelecionada = estrelas.find(estrela => estrela.mesh === intersects[0].object);
                    estrelaSelecionada.selecionar(); // Seleciona a nova estrela
                    mostrarInformacoes(estrelaSelecionada);
                }
            });

            function mostrarInformacoes(estrela) {
                const infoPanel = document.getElementById('starInfo');
                infoPanel.innerHTML = `
                    <strong>Posição:</strong> (${estrela.x.toFixed(2)}, ${estrela.y.toFixed(2)}, ${estrela.z.toFixed(2)})<br>
                    <strong>Tamanho:</strong> ${estrela.tamanho}<br>
                `;
            }

            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };

            document.addEventListener('mousedown', (event) => {
                isMouseDown = true;
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaMove = {
                        x: event.offsetX - previousMousePosition.x,
                        y: event.offsetY - previousMousePosition.y
                    };

                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            deltaMove.y * 0.01,
                            deltaMove.x * 0.01,
                            0,
                            'XYZ'
                        ));

                    camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                }

                previousMousePosition = {
                    x: event.offsetX,
                    y: event.offsetY
                };
            });

            function animate() {
                requestAnimationFrame(animate);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(estrelas.map(estrela => estrela.mesh));

                estrelas.forEach(estrela => estrela.voltarTamanho());
                if (intersects.length > 0) {
                    intersects[0].object.scale.set(1.5, 1.5, 1.5);
                }

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.05; // Aumentando o fator de zoom
                camera.position.z = Math.max(1, camera.position.z);
            });
        });
    </script>
</body>
</html>
